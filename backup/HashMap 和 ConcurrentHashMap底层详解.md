
HashMap 和 ConcurrentHashMap 是 Java 集合框架中用于存储键值对的核心类，前者是非线程安全的高效哈希表，后者是线程安全的高并发哈希表。以下从底层结构、核心操作、线程安全机制等维度深入解析两者的实现细节：


### 一、**HashMap 底层实现**
HashMap 是基于哈希表的 Map 实现，JDK 8 对其底层结构进行了重大优化（链表→红黑树），显著提升了哈希冲突时的查询性能。


#### **1. 核心存储结构：数组 + 链表 + 红黑树**
- **底层数组（Node[] table）**：也称为“哈希桶（Bucket）”，用于存储键值对节点（`Node<K,V>`）。数组的每个元素是一个链表或红黑树的根节点。
- **链表（Node）**：当哈希冲突时（不同键的哈希值映射到同一数组位置），冲突的键值对以链表形式存储（JDK 7 及之前为头插法，JDK 8 改为尾插法）。
- **红黑树（TreeNode）**：当链表长度 ≥ 8 且数组长度 ≥ 64 时，链表转换为红黑树（O(n) → O(logn) 查找）；当红黑树节点数 ≤ 6 时，退化为链表（避免频繁转换）。


#### **2. 关键参数**
| 参数               | 含义                                                                 | 默认值       |
|--------------------|----------------------------------------------------------------------|--------------|
| **初始容量**       | 底层数组的初始长度（必须为 2 的幂次）                                 | 16（`1<<4`） |
| **负载因子（loadFactor）** | 触发扩容的阈值（扩容阈值 = 容量 × 负载因子）                           | 0.75         |
| **树化阈值（TREEIFY_THRESHOLD）** | 链表转红黑树的链表长度阈值                                             | 8            |
| **反树化阈值（UNTREEIFY_THRESHOLD）** | 红黑树转链表的节点数阈值                                               | 6            |
| **最小树化容量（MIN_TREEIFY_CAPACITY）** | 链表转红黑树时，数组的最小长度（避免小容量下频繁树化）                 | 64           |


#### **3. 核心操作原理**
##### **(1) 哈希计算（hash 方法）**
HashMap 通过 `key.hashCode()` 计算哈希值，但为了减少哈希冲突，引入了**扰动函数**：
```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
- **作用**：将高 16 位与低 16 位异或，让哈希值的低位更随机，减少数组索引的冲突。
- **数组索引计算**：`(n - 1) & hash`（n 为数组长度，利用 2 的幂次特性，等价于取模但更高效）。


##### **(2) put 操作流程**
1. **初始化数组**：首次 put 时初始化数组（延迟初始化，默认大小 16）。
2. **计算索引**：通过 `(n-1) & hash` 定位数组桶的位置。
3. **处理冲突**：
   - 桶为空：直接插入新节点。
   - 桶非空：
     - 节点 key 相同（哈希值相等且 `equals` 为 true）：覆盖 value。
     - 节点是红黑树：调用 `putTreeVal` 插入树节点。
     - 节点是链表：遍历链表，尾插新节点；若链表长度 ≥8 且数组长度 ≥64，转换为红黑树。
4. **扩容检测**：当前元素数量超过扩容阈值（`size > threshold`），触发扩容。


##### **(3) 扩容机制（resize）**
- **触发条件**：元素数量超过 `threshold`（阈值 = 容量 × 负载因子）。
- **扩容步骤**：
  1. **数组翻倍**：新数组长度为原数组的 2 倍（保持 2 的幂次）。
  2. **重新哈希（rehash）**：将原数组中的节点迁移到新数组。JDK 8 优化了 rehash 逻辑：
     - 节点的新索引要么是原索引（`hash & oldCap == 0`），要么是原索引 + 原数组长度（`hash & oldCap != 0`）。
     - 链表拆分时保持原顺序（JDK 7 头插法可能导致多线程下的循环链表）。


##### **(4) get 操作流程**
1. 计算 key 的哈希值，定位数组桶。
2. 检查桶的第一个节点是否匹配（哈希值相等且 `equals` 为 true），匹配则返回。
3. 若桶是红黑树，调用 `getTreeNode` 查找。
4. 若桶是链表，遍历链表查找。


### 二、**ConcurrentHashMap 底层实现**
ConcurrentHashMap 是线程安全的哈希表，JDK 7 和 JDK 8 的实现差异较大：JDK 7 基于**分段锁（Segment）**，JDK 8 基于**节点 + CAS + synchronized**，锁粒度更细，性能更优。


#### **1. JDK 7：分段锁（Segment）**
##### **核心结构**
- **Segment 数组**：继承自 `ReentrantLock`，每个 Segment 对应一个锁，默认 16 个 Segment（可通过构造参数调整），支持 16 个线程并发写。
- **HashEntry 数组**：每个 Segment 包含一个 HashEntry 数组（存储键值对），类似 HashMap 的链表结构。

##### **线程安全机制**
- **写操作**：put 时先定位 Segment（通过 `hash % segments.length`），然后获取该 Segment 的锁（`ReentrantLock`），保证同一 Segment 内的操作互斥。
- **读操作**：无需加锁（通过 `volatile` 修饰 HashEntry 的 value 和 next 指针，保证可见性）。
- **size 计算**：需遍历所有 Segment 并加锁统计（可能需重试多次，直到所有 Segment 的 modCount 无变化）。


#### **2. JDK 8：节点 + CAS + synchronized**
JDK 8 放弃了分段锁设计，改用更细粒度的锁（直接锁定链表头节点或红黑树根节点），并结合 CAS 实现无锁操作，显著提升并发性能。


##### **核心结构**
- **Node 数组**：与 HashMap 类似，存储 `Node<K,V>` 节点（`val` 和 `next` 用 `volatile` 修饰，保证可见性）。
- **红黑树**：链表长度 ≥8 时转换为红黑树（同 HashMap）。
- **ForwardingNode**：扩容时的标记节点，用于多线程协助扩容。


##### **关键参数**
除与 HashMap 相同的参数外，新增：
| 参数               | 含义                                                                 | 默认值       |
|--------------------|----------------------------------------------------------------------|--------------|
| **sizeCtl**        | 控制数组初始化和扩容的状态变量（-1：初始化中；-N：N-1 个线程扩容；正数：扩容阈值） | 0            |


##### **核心操作原理**
##### **(1) put 操作流程**
1. **初始化数组**：首次 put 时通过 CAS + `synchronized` 初始化数组（仅一个线程执行）。
2. **计算索引**：同 HashMap，通过 `(n-1) & hash` 定位桶。
3. **CAS 插入**：若桶为空（`f == null`），通过 CAS 原子操作插入新节点。
4. **synchronized 锁节点**：若桶非空：
   - 若桶的 hash 为 `-1`（`ForwardingNode`），表示正在扩容，当前线程协助扩容。
   - 否则，对桶的头节点（`f`）加 `synchronized` 锁，处理链表或红黑树插入。
5. **树化检测**：链表长度 ≥8 时转换为红黑树（需检查数组长度 ≥64）。
6. **统计 size 并扩容**：通过 `addCount` 方法更新元素数量，若超过阈值则触发扩容。


##### **(2) 扩容机制（transfer）**
- **触发条件**：元素数量超过 `sizeCtl`（扩容阈值），或链表树化时数组长度 <64（此时仅扩容不树化）。
- **多线程协助扩容**：
  - 扩容时将原数组拆分为多个区间（`stride`），每个线程处理一个区间。
  - 迁移完成的桶标记为 `ForwardingNode`，其他线程访问时会协助扩容。
- **数据迁移**：同 HashMap，利用 `hash & oldCap` 将节点分配到原索引或原索引+原容量的位置。


##### **(3) 读操作（get）**
- 无需加锁，通过 `volatile` 修饰的 `Node.val` 和 `Node.next` 保证可见性。
- 若遇到 `ForwardingNode`，则到新数组中查找。


##### **(4) size 计算**
通过 `baseCount` 和 `CounterCell` 数组统计元素数量：
- **baseCount**：基础计数，CAS 更新。
- **CounterCell**：冲突时的增量计数（类似 LongAdder 的“分散计数”）。
- **sumCount()**：累加 `baseCount` 和所有 `CounterCell` 的值，得到总数量。


### 三、**HashMap vs ConcurrentHashMap 对比**
| 特性                | HashMap                          | ConcurrentHashMap                |
|---------------------|----------------------------------|-----------------------------------|
| **线程安全**         | 非线程安全（多线程下可能数据不一致或死循环） | 线程安全（JDK 7 分段锁，JDK 8 CAS+synchronized） |
| **锁粒度**           | 无锁                             | JDK 7：Segment（锁分段）；JDK 8：链表头/红黑树根（锁节点） |
| **null 键值**        | 允许（key 和 value 可为 null）   | 不允许（避免多线程下的歧义）       |
| **性能**             | 单线程高效                       | 多线程高并发场景下性能更优（JDK 8 锁粒度更细） |
| **扩容机制**         | 单线程扩容                       | 多线程协助扩容（JDK 8）            |
| **适用场景**         | 单线程缓存、临时数据存储         | 多线程环境（如分布式系统、高并发服务） |


### 四、**关键问题解答**
#### 1. **为什么 HashMap 链表转红黑树的阈值是 8？**
- **概率统计**：理想情况下（哈希函数均匀），链表长度遵循泊松分布，长度为 8 的概率仅约 0.00000006（千万分之六），实际中链表长度很少达到 8。树化阈值设为 8 是“空间换时间”的权衡。


#### 2. **ConcurrentHashMap JDK 8 为什么用 synchronized 而非 ReentrantLock？**
- **性能优化**：JDK 6 后 `synchronized` 引入了偏向锁、轻量级锁、自旋锁等优化，性能与 `ReentrantLock` 接近，且减少了内存开销（`ReentrantLock` 需额外的 AQS 同步状态）。
- **锁粒度更细**：`synchronized` 锁定的是链表头节点或红黑树根节点，而 `ReentrantLock` 需为每个节点单独加锁，实现复杂。


#### 3. **ConcurrentHashMap 如何保证可见性？**
- **volatile 变量**：`Node.val`、`Node.next`、`table` 数组（`volatile` 修饰）保证多线程间的可见性。
- **Happens-Before 规则**：CAS 操作和 `synchronized` 锁的释放-获取关系，确保操作的有序性。


### 五、**总结**
HashMap 是高效的非线程安全哈希表，适用于单线程场景；ConcurrentHashMap 通过细粒度锁和 CAS 实现了高并发下的线程安全，适用于多线程环境。理解两者的底层结构（数组+链表+红黑树）、核心操作（put/get/扩容）及线程安全机制（锁分段→节点锁），是掌握 Java 集合框架的关键。